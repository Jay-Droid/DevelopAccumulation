Q:
A:

Q: 说一下泛型中的继承关系？
A: Generic<A> 与 Generic<B> , Generic<A> 与 ChildGeneric<A>

Q: 说一下泛型通配符？
A: 通配符让转型更灵活
上届通配符 <？extends T>;
下届通配符<？super T>;
非限定通配符<?> == <? extends Object>



Q: 说一下Java泛型中的PECS原则？
A: PECS即 Producer extends Consumer super
如果你只需要从集合中获得类型T , 使用<? extends T>通配符
如果你只需要将类型T放到集合中, 使用<? super T>通配符
如果既不能存也不能取使用<?> 通配符
如果你既要获取又要放置元素，则不使用任何通配符。例如List<String>


Q: 为什么范型中的<？extends X> 通配符主要用于安全地读数据？<？super X>  通配符主要用于安全地写入数据？<?>  通配符既不能存也不能取？
A:
<？extends X>  表示类型的上界，类型参数 T 是 X 的子类，那么可以肯定的说，
get方法返回的一定是个 X（不管是X或者X的子类）编译器是可以确定知道的。
但是set方法只知道传入的是个 X，至于具体是 X 的那个子类，不知道。
总结：<？extends X> 限定符主要用于安全地读数据，可以访问 X 及其子类型，并且不能写入非null的数据。

 //<? extends Father> set方法不能写入
 // setData(T setData) 方法执行 this.data = setData;
 // 该语句是将 setData 的值赋值给 data (setData 和 data 泛型类型为 <? extends Father>) 表示限定 T 为 Father 的子类（包括 Father ）
 // 又因为子类可以安全的转型为父类，如果能找到一个Father类的最下届的子类就可以赋值，
 // 但是在Java中只有最上届的类型Object 不存在最下届的类型，所以没有这样的类型可以赋值给 data
 //extendFatherGenericClass.setData(father); //无法执行
 //extendFatherGenericClass.setData(son); //无法执行

  //<? extends Father> get方法只能读取出 Father 类型或 Father 的父类型
  // T getData() 方法执行 return data; 该语句是返回 data(data 泛型类型为 <? extends Father>) 表示限定 T 为 Father 的子类（包括 Father ）
  // 那什么样的类型可以存放取出来的这个 data 呢？只知道是 Father 的子类就行，但是不能确定是哪个子类，
  // 又因为子类可以安全的转型为父类, 所以作为 Father 所有子类中的父类 Father 以及 Father 的父类型肯定可以接收这个 data
  Father fatherData = extendFatherGenericClass.getData();
  Object fatherDat = extendFatherGenericClass.getData();


<？super X> 表示类型的下界，类型参数是 X 的父类（包括 X 本身），
public T getData() {return data;}
get() 方法返回的一定是个 X 的超类，那么到底是哪个超类？不知道，但是可以肯定的说，Object一定是它的Son超类，所以get方法返回Object。编译器是可以确定知道的。
public void setData(T data) { this.data = data; }
对于set()方法来说，编译器不知道它需要的确切类型，但是 X 和 X 的子类可以安全的转型为 X。
总结：<？super X> 限定符主要用于安全地写入数据，可以写入 X 及其子类型。

 // <? super Son> set方法只能写入Son本身和它的子类

 // setData(T setData) 方法是执行 this.data = setData;
 // 该语句是将 setData 的值赋值给 data (setData 和 data 泛型类型为 <? super Son>) 表示限定 T 为Son的父类（包括Son）
 // 又因为子类可以安全的转型为父类，所以作为最下届的子类型 Son(Son的子类也可以安全的转为Son类型)的数据类型肯定可以赋值给 data
 // supperSonGenericClass.setData(new Object()); //无法执行
 // supperSonGenericClass.setData(new Father()); //无法执行

 // <? super Son> get方法只能读取出 Object 类型
 // T getData() 方法执行 return data; 该语句是返回 data(data 泛型类型为 <? super Son>) 表示限定 T 为Son的父类（包括Son）
 // 那什么样的类型可以存放取出来的这个 data 呢？只知道是 Son 的父类就行，但是不能确定是哪个父类，
 // 又因为子类可以安全的转型为父类,所以作为最上届的父类型 Object 肯定可以接收这个data
 Object data = supperSonGenericClass.getData();
 //Son sonData = supperSonGenericClass.getData(); //无法执行

  <?> 指定了没有限定的通配符
  //<?> set方法不能写入人类类型

  // 因为子类可以安全的转型为父类，如果能找到一个任意一个的最下届的子类就可以赋值，
  // 但是在Java中只有最上届的类型 Object 不存在最下届的类型，所以没有这样的类型可以赋值给 data
  //genericClassCommon.setData(genericClass);
  //genericClassCommon.setData(new Object());

 // <?> get方法只能读取出 Object 类型

  //因为子类可以安全的转型为父类,所以不管什么类型，作为最上届的父类型 Object 肯定可以接收这个data
  Object object = genericClass.getData();